\documentclass[12pt, titlepage]{article}

\usepackage{fullpage}
\usepackage[round]{natbib}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}

\input{../../Comments}
\input{../../Common}

\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}

\begin{document}

\title{Module Guide for \progname{}} 
\author{\authname}
\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
2025-11-13 & 1.0 & Initial draft created and wrote the module decomposition
                and connections with requirements\\
2025-11-13 & 1.1 & Finalized the document and created the module hierarchy
                diagram \\
2026-01-21 & 1.2 & Rev 0, implemeneted TA feedback \\
\bottomrule
\end{tabularx}

\newpage

\section{Reference Material}

This section records information for easy reference.

\subsection{Abbreviations and Acronyms}

\noindent Additional symbols, abbreviations, and acronyms specific to this
document are listed below.

\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{p{3cm} p{11cm}}
\toprule
Symbol / Term & Definition \\
\midrule
:= & Assignment operator used for state transitions.\\
$\geq, \leq$ & Greater than or equal to, less than or equal to.\\
$\rightarrow$ & Function mapping or transition arrow.\\
Action & Atomic executable system behaviour.\\
BH & Behaviour-Hiding module (e.g., BH-Input, BH-Plan).\\
ExecStatus & Execution result (Pending, Success, or Failed).\\
FUNC.R.\# & Functional requirement number from the SRS.\\
Hazard ID & Identifier from Hazard Analysis (e.g., H1, H2).\\
HH & Hardware-Hiding module (e.g., HH-IO, HH-Auto).\\
InputMode & Input type (VoiceOnly, TextOnly, Mixed).\\
Intent & Structured interpretation of user command text.\\
MCP & Modular Command Protocol agent interface.\\
OutputMode & Output type (VoiceOnly, TextOnly, Both).\\
Plan & Structured action sequence from BH-Plan.\\
QA & Quality Assurance (software testing process).\\
RiskLevel & Safety classification for user actions.\\
SD & Software-Decision module (e.g., SD-Types, SD-Log).\\
SRS & System Requirements Specification.\\
STT & Speech-to-Text (audio input converted to text).\\
TTS & Text-to-Speech (text output converted to speech).\\
UI & User Interface.\\
V\&V & Verification and Validation Plan.\\
\bottomrule
\end{tabular}
\end{center}

\newpage

\tableofcontents

\listoftables

\listoffigures

\newpage

\pagenumbering{arabic}

\section{Introduction}

Decomposing a system into modules is a commonly accepted approach to developing
software. A module is a work assignment for a programmer or programming
team~\citep{ParnasEtAl1984}. We advocate a decomposition based on the principle
of information hiding~\citep{Parnas1972a}. This principle supports design for
change, because the ``secrets'' that each module hides represent likely future
changes. Design for change is valuable in SC, where modifications are frequent,
especially during initial development as the solution space is explored.

Our design follows the rules layed out by \citet{ParnasEtAl1984}, as follows:
\begin{itemize}
\item System details that are likely to change independently should be the
  secrets of separate modules.
\item Each data structure is implemented in only one module.
\item Any other program that requires information stored in a module's data
  structures must obtain it by calling access programs belonging to that
  module.
\end{itemize}

After completing the first stage of the design, the Software Requirements
Specification (SRS), the Module Guide (MG) is developed~\citep{ParnasEtAl1984}.
The MG specifies the modular structure of the system and is intended to allow
both designers and maintainers to easily identify the parts of the software.
The potential readers of this document are as follows:

\begin{itemize}
\item New project members: This document can be a guide for a new project member
  to easily understand the overall structure and quickly find the relevant
  modules they are searching for.
\item Maintainers: The hierarchical structure of the module guide improves the
  maintainers' understanding when they need to make changes to the system. It
  is important for a maintainer to update the relevant sections of the document
  after changes have been made.
\item Designers: Once the module guide has been written, it can be used to
  check for consistency, feasibility, and flexibility. Designers can verify
  the system in various ways, such as consistency among modules, feasibility
  of the decomposition, and flexibility of the design.
\end{itemize}

The rest of the document is organized as follows. Section \ref{SecChange} lists
the anticipated and unlikely changes of the software requirements. Section
\ref{SecMH} summarizes the module decomposition that was constructed according
to the likely changes. Section \ref{SecConnection} specifies the connections
between the software requirements and the modules. Section \ref{SecMD} gives a
detailed description of the modules. Section \ref{SecTM} includes traceability
tables. Section \ref{SecUse} describes the use relation between modules.

\section{Anticipated and Unlikely Changes} \label{SecChange}

This section lists possible changes to the system. According to the likeliness
of the change, the possible changes are classified into two categories.
Anticipated changes are listed in Section \ref{SecAchange}, and unlikely
changes are listed in Section \ref{SecUchange}.

\subsection{Anticipated Changes} \label{SecAchange}

Anticipated changes are the source of the information that is to be hidden
inside the modules. Ideally, changing one of the anticipated changes will only
require changing the one module that hides the associated decision. The
approach adapted here is called design for change.

\begin{description}
\item[\refstepcounter{acnum} \actheacnum \label{acHardware}:]
The specific hardware on which the software is running (e.g., microphone or
speaker models).
\item[\refstepcounter{acnum} \actheacnum \label{acInput}:]
The format or source of input data (e.g., switching from voice-only to mixed
input modes).
\item[\refstepcounter{acnum} \actheacnum \label{acSTT}:]
The speech recognition or text-to-speech library (e.g., replacing Whisper API
with a local model).
\item[\refstepcounter{acnum} \actheacnum \label{acUI}:]
The user interface layout or feedback presentation (e.g., visual vs.\ voice-only
output).
\item[\refstepcounter{acnum} \actheacnum \label{acCommands}:]
The set of supported voice commands or MCP tools.
\item[\refstepcounter{acnum} \actheacnum \label{acThresholds}:]
The thresholds for speech detection and timing between input and response.
\item[\refstepcounter{acnum} \actheacnum \label{acSafety}:]
The risk classification policy for safety confirmation (e.g., adding new risk
levels or modifying approval logic).
\item[\refstepcounter{acnum} \actheacnum \label{acStorage}:]
The logging format or storage mechanism for session history and user
preferences.
\end{description}

\subsection{Unlikely Changes} \label{SecUchange}

The module design should be as general as possible. However, a general system is
more complex. Sometimes this complexity is not necessary. Fixing some design
decisions at the system architecture stage can simplify the software design. If
these decision should later need to be changed, then many parts of the design
will potentially need to be modified. Hence, it is not intended that these
decisions will be changed.

\begin{description}
\item[\refstepcounter{ucnum} \uctheucnum \label{ucPipeline}:]
The main processing loop of Input $\rightarrow$ Interpret $\rightarrow$ Plan
$\rightarrow$ Execute $\rightarrow$ Feedback.
\item[\refstepcounter{ucnum} \uctheucnum \label{ucDataStructures}:]
The core data structures used for storing Commands, Intents, and Action Plans.
\item[\refstepcounter{ucnum} \uctheucnum \label{ucMCP}:]
A local, reliable, request-response communication style between modules via the
MCP agent interface (structured JSON requests and responses).
\item[\refstepcounter{ucnum} \uctheucnum \label{ucDeployment}:]
The product runs as a single desktop application in one process (no distributed
deployment across devices).
\end{description}

\section{Module Hierarchy} \label{SecMH}

This section provides an overview of the module design. Modules are summarized
in a hierarchy decomposed by secrets in Table \ref{TblMH}. The modules listed
below, which are leaves in the hierarchy tree, are the modules that will
actually be implemented.

\begin{description}

  % HH
  \item [\refstepcounter{mnum} \mthemnum \label{mHHIO}:]
  \textbf{HH-IO (Audio I/O Adapter)} manages microphone input and audio output
  across platforms.
  \item [\refstepcounter{mnum} \mthemnum \label{mHHAuto}:]
  \textbf{HH-Auto (Desktop Automation)} performs desktop automation tasks such
  as typing, clicking, and launching applications.

  % BH
  \item [\refstepcounter{mnum} \mthemnum \label{mBHInput}:]
  \textbf{BH-Input (Voice \& Text Manager)} captures user speech, uses Whisper
  STT, and normalizes input.
  \item [\refstepcounter{mnum} \mthemnum \label{mBHNLU}:]
  \textbf{BH-NLU (Intent Parser)} interprets text into structured intents based
  on command patterns.
  \item [\refstepcounter{mnum} \mthemnum \label{mBHPlan}:]
  \textbf{BH-Plan (Task Planner and Executor)} selects MCP tools and executes
  user intents.
  \item [\refstepcounter{mnum} \mthemnum \label{mBHSafety}:]
  \textbf{BH-Safety (Safety Confirmation Gate)} validates risky actions and
  requests confirmation as needed.
  \item [\refstepcounter{mnum} \mthemnum \label{mBHSession}:]
  \textbf{BH-Session (Session Context Manager)} stores history, session
  context, and undo information.
  \item [\refstepcounter{mnum} \mthemnum \label{mBHFeedback}:]
  \textbf{BH-Feedback (Feedback Output Manager)} outputs responses using TTS or
  visual text.
  \item [\refstepcounter{mnum} \mthemnum \label{mBHUI}:]
  \textbf{BH-UI (User Interface Panel)} displays status, confirmation prompts,
  and results.

  % SD
  \item [\refstepcounter{mnum} \mthemnum \label{mSDTypes}:]
  \textbf{SD-Types (Core Data Types)} defines ADTs for Command, Intent, Plan,
  and related structures.
  \item [\refstepcounter{mnum} \mthemnum \label{mSDRegistry}:]
  \textbf{SD-ToolRegistry (Tool Registry)} maps intents to MCP tools and
  actions.
  \item [\refstepcounter{mnum} \mthemnum \label{mSDStore}:]
  \textbf{SD-Store (Persistent Store)} manages persistent data such as
  preferences, session history, and logs.
  \item [\refstepcounter{mnum} \mthemnum \label{mSDConfig}:]
  \textbf{SD-AIClient (AI Service Client)} provides configuration and API
  communication for STT, TTS, and LLM services.
  \item [\refstepcounter{mnum} \mthemnum \label{mSDLog}:]
  \textbf{SD-Log (Event Logger)} records events for debugging and V\&V
  traceability.

\end{description}

\section{Connection Between Requirements and Design} \label{SecConnection}

The design of the system is intended to satisfy the requirements developed in
the SRS. In this stage, the system is decomposed into modules. The connection
between requirements and modules is listed in Table~\ref{TblRT}.

\begin{itemize}
    \item \textbf{Multi-modal Input Pipeline}: FUNC.R.1 and FUNC.R.2 required
    handling both speech and text input with accurate conversion. This led to a
    coordinated design where \textbf{BH-Input} manages high-level input
    processing, \textbf{HH-IO} handles hardware-level audio operations, and
    \textbf{BH-UI} provides the interface layer, with \textbf{SD-AIClient}
    ensuring proper speech configuration and service calls.

    \item \textbf{Natural Language Understanding Chain}: FUNC.R.3's intent
    interpretation requirement resulted in a processing chain where
    \textbf{BH-NLU} performs core parsing, supported by \textbf{BH-Input} for
    pre-processed text and \textbf{SD-Types} for structured data definitions.

    \item \textbf{Comprehensive Task Execution Framework}: FUNC.R.4's planning
    and execution requirement necessitated a multi-module approach where
    \textbf{BH-Plan} coordinates execution, \textbf{SD-ToolRegistry} maps intents
    to tools, \textbf{HH-Auto} performs low-level actions, \textbf{BH-Session}
    maintains context, and \textbf{BH-Safety} ensures secure operation.

    \item \textbf{Distributed Logging Architecture}: FUNC.R.7's comprehensive
    logging requirement is satisfied by making \textbf{SD-Log} a central service
    used by nearly all modules, with \textbf{SD-Store} handling persistent
    storage of log data.

    \item \textbf{High-Level Interaction Abstraction}: FUNC.R.8's requirement to
    avoid low-level OS details is achieved through a layered architecture where
    \textbf{BH-UI}, \textbf{BH-Input}, and \textbf{BH-Feedback} provide natural
    language interfaces, while \textbf{BH-Plan} and \textbf{SD-Types} maintain
    high-level abstractions that shield users from system complexities.

    \item \textbf{Safety-Critical Confirmation System}: FUNC.R.9's confirmation
    requirement led to the \textbf{BH-Safety} module that intercepts privileged
    actions, coordinated with \textbf{BH-UI} for user prompts and multiple SD
    modules for persistence and auditing.

    \item \textbf{Speed and Latency (SAL.R.1, SAL.R.2)}: To meet the 2-second
    response time requirement, we designed \textbf{BH-Input} with efficient
    audio buffering and \textbf{BH-Feedback} with immediate acknowledgment
    patterns. The modular architecture allows parallel processing where
    possible, and \textbf{HH-Auto} is optimized for quick execution of common
    actions.

    \item \textbf{Safety-Critical Operations (SAF.R.1, SAF.R.2)}: The
    \textbf{BH-Safety} module was specifically created to enforce confirmation
    requirements for file and system changes. \textbf{BH-Session} maintains
    action history to support single-step undo functionality, working with
    \textbf{SD-Store} for persistent state management.

    \item \textbf{Precision and Accuracy (POA.R.1, POA.R.2)}: Accuracy
    requirements drove the separation of \textbf{BH-Input} for robust speech
    processing and \textbf{SD-AIClient} for fine-tuning recognition parameters.
    The modular design allows swapping STT engines without affecting other
    system components.

    \item \textbf{Robustness and Fault Tolerance (ROFT.R.1, ROFT.R.2)}:
    \textbf{SD-Log} provides comprehensive error logging without disrupting
    operation, while each BH module implements graceful error handling. The use
    of \textbf{SD-Types} ensures data consistency even with invalid inputs.

    \item \textbf{Capacity Requirements (CAP.R.1, CAP.R.2)}: The modular design
    enables efficient resource management, with \textbf{BH-Plan} optimizing tool
    execution and \textbf{SD-ToolRegistry} enabling lazy loading of infrequently
    used components to maintain low CPU usage during extended operation.

    \item \textbf{Scalability and Extensibility (SOE.R.1, SOE.R.2)}: The
    plugin-like architecture of \textbf{SD-ToolRegistry} allows new tools to be
    added seamlessly, while the clear interfaces between modules ensure that
    new features can be integrated without major refactoring.
\end{itemize}

\section{Module Decomposition} \label{SecMD}

Modules are decomposed according to the principle of ``information hiding''
proposed by \citet{ParnasEtAl1984}. The \emph{Secrets} field in a module
decomposition is a brief statement of the design decision hidden by the module.
The \emph{Services} field specifies \emph{what} the module will do without
documenting \emph{how} to do it. For each module, a suggestion for the
implementing software is given under the \emph{Implemented By} title. If the
entry is \emph{OS}, this means that the module is provided by the operating
system or by standard programming language libraries. \emph{\progname{}} means
the module will be implemented by the \progname{} software.

Only the leaf modules in the hierarchy have to be implemented. If a dash
(\emph{--}) is shown, this means that the module is not a leaf and will not
have to be implemented.

\subsection{Hardware Hiding Modules (\mref{mHHIO})-(\mref{mHHAuto})}

The hardware-hiding modules isolate platform and device differences from the
rest of the system. They provide stable interfaces for audio I/O and desktop
automation so higher-level modules do not depend on OS or device details.

\subsubsection{HH-IO: Audio I/O Adapter (\mref{mHHIO})}
\begin{description}
\item[Secrets:] The data structure and algorithm used to interface with
microphone and speaker hardware.
\item[Services:] Provides audio hardware I/O operations including opening and
closing devices, recording audio, and playing audio.
\item[Implemented By:] OS audio libraries
\item[Type Of Module:] Library
\end{description}

\subsubsection{HH-Auto: Desktop Automation (\mref{mHHAuto})}
\begin{description}
\item[Secrets:] OS specific automation (mouse and keyboard control)
implementation. Hides differences between Windows, macOS, and Linux.
\item[Services:] Move cursor, click, type, and launch applications.
\item[Implemented By:] PyAutoGUI
\item[Type Of Module:] Library
\end{description}

\subsection{Behaviour-Hiding Modules (\mref{mBHInput})-(\mref{mBHUI})}

The behaviour-hiding modules implement the end-to-end interaction pipeline:
capture input, interpret intent, plan actions, enforce safety, manage session
context, and present feedback to the user.

\subsubsection{BH-Input: Voice and Text Manager (\mref{mBHInput})}
\begin{description}
\item[Secrets:] Speech-to-text configuration, text normalization rules, and
buffering strategies.
\item[Services:] Handles speech variation, different speech patterns, varied
accents, and filters background noise.
\item[Implemented By:] \progname{}
\item[Type Of Module:] Abstract Object
\end{description}

\subsubsection{BH-NLU: Intent Parser (\mref{mBHNLU})}
\begin{description}
\item[Secrets:] Rules and internal parameters for interpretation of noisy or
imperfect text into structured intent objects.
\item[Services:] Converts normalized text into intents with metadata fields.
\item[Implemented By:] \progname{}
\item[Type Of Module:] Library
\end{description}

\subsubsection{BH-Plan: Task Planner and Executor (\mref{mBHPlan})}
\begin{description}
\item[Secrets:] Decision-making logic for selecting the correct MCP agent based
on intent, execution planning, and error handling.
\item[Services:] Creates an execution plan based on intent, executes the plan
using MCP tools, and tracks tasks to completion.
\item[Implemented By:] \progname{}
\item[Type Of Module:] Abstract Object
\end{description}

\subsubsection{BH-Safety: Safety Confirmation Gate (\mref{mBHSafety})}
\begin{description}
\item[Secrets:] Risk analysis policy table, irreversible detection rules, and
timeout behaviour.
\item[Services:] Classifies action risks, decides an appropriate policy, and
prompts the user for confirmation when an action is deemed high risk.
\item[Implemented By:] \progname{}
\item[Type Of Module:] Abstract Object
\end{description}

\subsubsection{BH-Session: Session Context Manager (\mref{mBHSession})}
\begin{description}
\item[Secrets:] Session history table, short-term conversational context for the
AI model, and previous action history for undo.
\item[Services:] Tracks sessions and actions. Maintains continuity across user
requests and stores short-term model context in memory.
\item[Implemented By:] \progname{}
\item[Type Of Module:] Abstract Object
\end{description}

\subsubsection{BH-Feedback: Feedback Output Manager (\mref{mBHFeedback})}
\begin{description}
\item[Secrets:] Output action logic, text-to-speech configuration, and message
delivery monitoring.
\item[Services:] Converts messages to speech and outputs through speakers if
required, and mirrors speech as text feedback.
\item[Implemented By:] \progname{}
\item[Type Of Module:] Abstract Object
\end{description}

\subsubsection{BH-UI: User Interface Panel (\mref{mBHUI})}
\begin{description}
\item[Secrets:] View groups, information presentation rules, and prompt timing
rules.
\item[Services:] Updates UI state, displays messages, and presents user prompts.
\item[Implemented By:] \progname{}
\item[Type Of Module:] Abstract Object
\end{description}

\subsection{Software Decision Modules (\mref{mSDTypes})-(\mref{mSDLog})}

The software-decision modules define shared data representations and system-wide
services such as tool mapping, persistence, AI service integration, and logging.

\subsubsection{SD-Types: Core Data Types (\mref{mSDTypes})}
\begin{description}
\item[Secrets:] Internal representation of commands, actions, risks, policies,
and tool metadata.
\item[Services:] Defines shared ADTs used system-wide.
\item[Implemented By:] \progname{}
\item[Type Of Module:] Abstract Data Type
\end{description}

\subsubsection{SD-ToolRegistry: Tool Registry (\mref{mSDRegistry})}
\begin{description}
\item[Secrets:] Mapping from intent types to MCP tools, agents, and automation
routines.
\item[Services:] Provides the appropriate MCP tool or agent for a given intent.
\item[Implemented By:] \progname{}
\item[Type Of Module:] Abstract Object
\end{description}

\subsubsection{SD-Store: Persistent Store (\mref{mSDStore})}
\begin{description}
\item[Secrets:] Persistent storage format and schema for user settings, session
history, and logs.
\item[Services:] Saves and loads user settings and previously saved states from
persistent storage. (Short-term model context is handled by BH-Session.)
\item[Implemented By:] \progname{}
\item[Type Of Module:] Abstract Object
\end{description}

\subsubsection{SD-AIClient: AI Service Client (\mref{mSDConfig})}
\begin{description}
\item[Secrets:] API keys, configurations, timeouts, retry policy, and fallback
options for external STT, TTS, and LLM services.
\item[Services:] Provides the communication layer for AI services and exposes
stable routines for transcription and speech synthesis to BH modules.
\item[Implemented By:] \progname{}
\item[Type Of Module:] Abstract Object
\end{description}

\subsubsection{SD-Log: Event Logger (\mref{mSDLog})}
\begin{description}
\item[Secrets:] Diagnostic log formatter and persistence policy.
\item[Services:] Records events and errors for debugging and V\&V traceability.
\item[Implemented By:] \progname{}
\item[Type Of Module:] Abstract Object
\end{description}

\section{Traceability Tables} \label{SecTM}

This section shows traceability tables between the modules and the functional
requirements plus nonfunctional requirements, and between the modules and the
anticipated changes. Tables \ref{TblRT}, \ref{TblNFRRT}, \ref{TblNFRRTCont}, and
\ref{TblACT} collectively provide coverage and change-impact traceability.

\begin{table}[H]
\centering
\caption{Traceability between functional requirements and modules}
\label{TblRT}
\renewcommand{\arraystretch}{1.1}
\begin{tabular}{p{0.32\textwidth} p{0.58\textwidth}}
\toprule
\textbf{Requirement (SRS)} & \textbf{Modules}\\
\midrule
FUNC.R.1 - Accept input via speech and text
  & \mref{mBHInput}, \mref{mHHIO}, \mref{mBHUI}, \mref{mSDConfig} \\
FUNC.R.2 - Convert speech to text (STT)
  & \mref{mBHInput}, \mref{mHHIO}, \mref{mSDConfig}, \mref{mSDLog} \\
FUNC.R.3 - Interpret user intent from NL input
  & \mref{mBHNLU}, \mref{mBHInput}, \mref{mSDTypes}, \mref{mSDLog} \\
FUNC.R.4 - Plan and execute tasks via agents/tools
  & \mref{mBHPlan}, \mref{mSDRegistry}, \mref{mSDTypes},
    \mref{mHHAuto}, \mref{mBHSession}, \mref{mBHSafety}, \mref{mSDLog} \\
FUNC.R.5 - Provide textual/spoken feedback
  & \mref{mBHFeedback}, \mref{mBHUI}, \mref{mSDConfig}, \mref{mSDLog} \\
FUNC.R.6 - Maintain short-term conversational memory
  & \mref{mBHSession}, \mref{mSDStore}, \mref{mBHInput},
    \mref{mBHPlan}, \mref{mSDLog} \\
FUNC.R.7 - Log user interactions and task results
  & \mref{mSDLog}, \mref{mSDStore}, \mref{mBHSession},
    \mref{mBHInput}, \mref{mBHPlan}, \mref{mBHFeedback},
    \mref{mBHUI}, \mref{mBHSafety}, \mref{mHHIO}, \mref{mHHAuto} \\
FUNC.R.8 - High-level interaction (no low-level OS details)
  & \mref{mBHUI}, \mref{mBHInput}, \mref{mBHPlan},
    \mref{mBHFeedback}, \mref{mHHAuto}, \mref{mSDTypes} \\
FUNC.R.9 - Confirm privileged/system-level actions
  & \mref{mBHSafety}, \mref{mBHUI}, \mref{mBHPlan},
    \mref{mSDTypes}, \mref{mSDLog}, \mref{mSDStore} \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Traceability between nonfunctional requirements and modules}
\label{TblNFRRT}
\renewcommand{\arraystretch}{1.1}
\begin{tabular}{p{0.32\textwidth} p{0.58\textwidth}}
\toprule
\textbf{Nonfunctional Requirement} & \textbf{Modules}\\
\midrule
APP.1--APP.5 (Appearance)
  & \mref{mBHUI}, \mref{mBHFeedback}, \mref{mBHInput}, \mref{mSDConfig},
    \mref{mSDStore} \\
STY.1--STY.3 (Style)
  & \mref{mBHUI}, \mref{mBHFeedback} \\
EOU.R.1--EOU.R.3 (Ease of use)
  & \mref{mBHUI}, \mref{mBHInput}, \mref{mBHPlan}, \mref{mBHFeedback},
    \mref{mBHSession} \\
PER.R.1--PER.R.2 (Personalization)
  & \mref{mBHInput}, \mref{mBHSession}, \mref{mSDStore}, \mref{mSDConfig} \\
LEA.R.1--LEA.R.2 (Learning support)
  & \mref{mBHUI}, \mref{mBHFeedback}, \mref{mBHInput}, \mref{mSDStore} \\
UAP.R.1--UAP.R.3 (Understandability and politeness)
  & \mref{mBHUI}, \mref{mBHFeedback}, \mref{mBHPlan}, \mref{mBHSafety} \\
ACC.R.1--ACC.R.2 (Accessibility)
  & \mref{mBHUI}, \mref{mBHInput}, \mref{mBHFeedback}, \mref{mHHIO},
    \mref{mSDConfig} \\
SAL.R.1--SAL.R.2 (Speed and latency)
  & \mref{mHHIO}, \mref{mBHInput}, \mref{mBHPlan}, \mref{mSDConfig},
    \mref{mSDLog} \\
SAF.R.1--SAF.R.2 (Safety-critical behaviour)
  & \mref{mBHSafety}, \mref{mBHPlan}, \mref{mBHUI}, \mref{mHHAuto},
    \mref{mSDTypes}, \mref{mSDStore}, \mref{mSDLog} \\
POA.R.1--POA.R.2 (Precision/accuracy)
  & \mref{mBHInput}, \mref{mSDConfig}, \mref{mSDLog} \\
ROFT.R.1--ROFT.R.2 (Robustness/fault-tolerance)
  & \mref{mSDLog}, \mref{mSDStore}, \mref{mBHInput}, \mref{mBHPlan},
    \mref{mBHSession} \\
CAP.R.1--CAP.R.2 (Capacity)
  & \mref{mHHIO}, \mref{mBHInput}, \mref{mBHPlan}, \mref{mBHSession},
    \mref{mSDStore}, \mref{mSDConfig} \\
SOE.R.1--SOE.R.2 (Scalability/extensibility)
  & \mref{mSDTypes}, \mref{mSDRegistry}, \mref{mSDStore}, \mref{mBHPlan} \\
LON.R.1--LON.R.2 (Longevity)
  & \mref{mSDStore}, \mref{mSDLog}, \mref{mBHSession}, \mref{mBHUI} \\
EPE.R.1--EPE.R.4 (Expected physical environment)
  & \mref{mHHIO}, \mref{mBHInput}, \mref{mSDConfig} \\
WER.R.1--WER.R.2 (Wider environment)
  & \mref{mBHPlan}, \mref{mHHAuto}, \mref{mSDRegistry}, \mref{mSDConfig} \\
IAS.R.1--IAS.R.4 (Interfaces with adjacent systems)
  & \mref{mBHInput}, \mref{mBHFeedback}, \mref{mBHPlan}, \mref{mSDRegistry},
    \mref{mSDConfig}, \mref{mSDLog} \\
PRD.R.1--PRD.R.3 (Productization)
  & \mref{mSDStore}, \mref{mSDConfig}, \mref{mSDTypes} \\
REL.R.1--REL.R.2 (Release)
  & \mref{mSDLog}, \mref{mSDStore} \\
ACS-01--ACS-02 (Access control)
  & \mref{mBHUI}, \mref{mBHPlan}, \mref{mBHSafety}, \mref{mSDConfig},
    \mref{mSDStore} \\
INT-01 (Integrity)
  & \mref{mSDStore}, \mref{mSDLog} \\
PRIV-01 (Privacy)
  & \mref{mBHInput}, \mref{mBHPlan}, \mref{mSDStore}, \mref{mSDConfig},
    \mref{mSDLog} \\
IMM-01--IMM-02 (Immunity)
  & \mref{mSDConfig}, \mref{mSDLog} \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Traceability between nonfunctional requirements and modules continued}
\label{TblNFRRTCont}
\renewcommand{\arraystretch}{1.1}
\begin{tabular}{p{0.32\textwidth} p{0.58\textwidth}}
\toprule
\textbf{Nonfunctional Requirements Continued} & \textbf{Modules}\\
\midrule
CULR-01--CULR-02 (Cultural)
  & \mref{mBHUI}, \mref{mBHFeedback}, \mref{mBHInput} \\
LGL-01--LGL-02 (Legal)
  & \mref{mSDStore}, \mref{mSDLog}, \mref{mBHUI} \\
STDCOMP-01--STDCOMP-02 (Standards compliance)
  & \mref{mBHUI}, \mref{mBHFeedback}, \mref{mSDTypes}, \mref{mSDStore} \\
\bottomrule
\end{tabular}
\end{table}

The following table links anticipated changes (ACs) from
Section~\ref{SecChange} to the modules that hide the corresponding design
decisions.

\begin{table}[H]
\centering
\caption{Traceability between anticipated changes and modules}
\label{TblACT}
\renewcommand{\arraystretch}{1.1}
\begin{tabular}{p{0.32\textwidth} p{0.58\textwidth}}
\toprule
\textbf{Anticipated Change} & \textbf{Modules}\\
\midrule
\acref{acHardware} - Hardware platform (microphone, speakers, OS automation)
  & \mref{mHHIO}, \mref{mHHAuto} \\
\acref{acInput} - Input format / source (voice-only~vs.~mixed voice + text)
  & \mref{mBHInput}, \mref{mBHUI}, \mref{mHHIO} \\
\acref{acSTT} - STT/TTS/LLM provider or library
  & \mref{mBHInput}, \mref{mBHFeedback}, \mref{mHHIO}, \mref{mSDConfig} \\
\acref{acUI} - UI layout and feedback presentation
  & \mref{mBHUI}, \mref{mBHFeedback}, \mref{mSDStore} \\
\acref{acCommands} - Supported voice commands and MCP tools
  & \mref{mBHNLU}, \mref{mBHPlan}, \mref{mSDRegistry}, \mref{mSDTypes} \\
\acref{acThresholds} - Speech detection and timing thresholds
  & \mref{mBHInput}, \mref{mHHIO}, \mref{mSDConfig} \\
\acref{acSafety} - Risk classification and safety policy
  & \mref{mBHSafety}, \mref{mBHUI}, \mref{mSDTypes}, \mref{mSDStore},
    \mref{mSDLog} \\
\acref{acStorage} - Logging and storage of history/preferences
  & \mref{mSDStore}, \mref{mSDLog}, \mref{mBHSession} \\
\bottomrule
\end{tabular}
\end{table}

\section{Use Hierarchy Between Modules} \label{SecUse}

In this section, the uses hierarchy between modules is provided.
\citet{Parnas1978} said of two programs A and B that A {\em uses} B if correct
execution of B may be necessary for A to complete the task described in its
specification. That is, A {\em uses} B if there exist situations in which the
correct functioning of A depends upon the availability of a correct
implementation of B. Figure \ref{FigUH} illustrates the use relation between the
modules. It can be seen that the graph is a directed acyclic graph (DAG). Each
level of the hierarchy offers a testable and usable subset of the system, and
modules in the higher level of the hierarchy are essentially simpler because
they use modules from the lower levels.

\begin{figure}[H]
\centering
\includegraphics[width=1.15\textwidth,trim=50 0 0 0,clip]{UsesHierarchy.pdf}
\caption{Use hierarchy among modules}
\label{FigUH}
\end{figure}

\section{User Interfaces}

This section goes over the user interfaces. The UI is designed to have a voice
first interaction while also having keyboard and mouse input as secondary
options.

\subsection{Main Desktop Panel}

The primary interface is a desktop window that can be visible while the user
works in other applications. It can also run in background and will listen to
user. It gives:

\begin{itemize}
  \item A clear indication of whether the program is idle, listening, processing,
    or waiting for any confirmation.
  \item A single prominent control to start/stop voice capture.
  \item A transcript area showing recent commands and responses (captioning of
    spoken feedback).
  \item Simple, high-level controls for undoing, approving, or cancelling
    actions.
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{MainUI.png}
  \caption{Mockup of the main Proxi interface}
  \label{FigMainUI}
\end{figure}

\subsection{Layout and Elements}

The window is divided into three regions:

\begin{description}
  \item[Top bar:] Shows the application name (Proxi Voice Assistant) and a
  status label (Idle, Listening, Processing, etc.)
  \item[Center:] A large Mic control to start/stop capture and a transcript area
  that displays the most recent user command and Proxi's response.
  \item[Bottom row:] Action buttons for Undo, Approve, and Cancel, plus a
  Settings control.
\end{description}

\subsection{Accessibility Notes}

\begin{description}
  \item[Voice parity:] Every visible action (Listen, Undo, Approve, Cancel) also
  has an equivalent voice command handled by the BH modules.
  \item[Keyboard access:] All controls are reachable via keyboard focus and
  shortcuts so users do not need a mouse.
  \item[Captioning:] Spoken feedback is always mirrored as text in the transcript
  area to satisfy captioning requirements.
\end{description}

\section{Design of Communication Protocols}
\label{SecComm}

\noindent No custom low-level communication protocols are defined.

\subsection{Internal Communication}

All modules run in a single desktop application and communicate through normal
procedure calls and shared data structures. No network protocols are used in
internal modules.

\subsection{External Services}

\begin{itemize}
  \item \textbf{STT/TTS/LLM services}: \mref{mSDConfig} provides the API client
  layer used by \mref{mBHInput} and \mref{mBHFeedback} over standard HTTPS with
  JSON payloads.

  \item \textbf{MCP tools and automation}: \mref{mBHPlan} uses MCP tools and
  desktop automation through a local MCP channel exchanging JSON requests and
  responses. Tool mapping is maintained by \mref{mSDRegistry}.
\end{itemize}

\section{Timeline}

This schedule decomposes the development of Rev 0 into four distinct phases, 
mapping internal procedures to the module hierarchy and assigning team members 
based on the Module Guide.

\subsection{Phase 1: Foundations \& Core Data Structures (Weeks 0-3)}
\textit{Goal: Establish the shared symbolic language, hardware I/O links, and 
logging infrastructure.}

\begin{tabularx}{\textwidth}{|l|l|l|X|}
\hline
\textbf{Date} & \textbf{Module(s)} & \textbf{Lead(s)} & \textbf{Details} 
\\ \hline
Nov 15 - Nov 29  & M13, M14 & Ajay & \textbf{Setup:} Environment configuration and 
implementation of \texttt{log\_event()} for system-wide traceability 
(FUNC.R.7). \\ \hline
Nov 30 - Dec 9 & M10 & Gourob & \textbf{Type-Definition:} Coding of global 
ADTs (\texttt{Command}, \texttt{Intent}, \texttt{Plan}) to ensure type-safety 
across the pipeline. \\ \hline
Dec 10 - Dec 19 & M1 & Amanbeer & \textbf{Signal-Capture:} Low-level implementation 
of \texttt{init\_audio()} and \texttt{start\_capture()} using hardware-hiding 
drivers. \\ \hline
Dec 20 - Dec 31 & M1 & Amanbeer & \textbf{Feedback-Link:} Implementation 
of \texttt{play\_feedback()} to route synthetic audio to system output devices. 
\\ \hline
\end{tabularx}

\subsection{Phase 2: Semantic Pipeline \& NLU (Weeks 4-7)}
\textit{Goal: Transition from raw  to structured user intent and 
persistent storage.}

\begin{tabularx}{\textwidth}{|l|l|l|X|}
\hline
\textbf{Week} & \textbf{Module(s)} & \textbf{Lead(s)} & \textbf{Details} 
\\ \hline
Jan 1 - Jan 9 & M3 & Savinay & \textbf{Stream-to-Text:} Integration of Whisper STT; 
implementation of VAD (Voice Activity Detection) logic. \\ \hline
Jan 10 - Jan 19 & M3, M4 & Savinay, Gourob & \textbf{Normalization:} Unifying Voice and Text 
inputs into a common \texttt{Command} object via \texttt{get\_input()}. \\ 
\hline
Jan 20 - Jan 31 & M4 & Gourob & \textbf{Semantic-Parser:} Development of rules to map natural 
language strings to structured \texttt{Intent} objects. \\ \hline
Feb 1 - Feb 9 & M11, M12 & Ajay & \textbf{Action-Map:} Building the \texttt{SD-ToolRegistry} 
to link parsed intents to specific system automation tools. \\ \hline
\end{tabularx}


\subsection{Phase 3: Execution, Automation \& Safety (Weeks 8-11)}
\textit{Goal: Procedural planning, secure OS use, and session context.}

\begin{tabularx}{\textwidth}{|l|l|l|X|}
\hline
\textbf{Week} & \textbf{Module(s)} & \textbf{Lead(s)} & \textbf{Details} \\ \hline
Feb 10 - Feb 19 & M5 & Gourob & \textbf{Logic-Sequence:} Implementation of recursive planning 
to decompose intents into atomic \texttt{Action} sequences. \\ \hline
Feb 20 - Feb 28 & M2 & Amanbeer & \textbf{OS-Abstraction:} Development of keyboard and 
mouse automation wrappers (click, type, launch) for Windows/macOS. \\ \hline
Mar 1 - Mar 9 & M6 & Savinay & \textbf{Gate-Keeper:} Mandatory implementation of 
\texttt{validate\_plan()} to intercept high-risk/irreversible actions 
(FUNC.R.9). \\ \hline
Mar 10 - Mar 19 & M7 & Ajay & \textbf{Context-Sync:} Implementing conversational memory to 
track history and support "undo" operations. \\ \hline
\end{tabularx}

\subsection{Phase 4: Feedback Loop \& Integration (Weeks 12-14)}
\textit{Goal: Closing the user interaction loop and final V\&V testing.}

\begin{tabularx}{\textwidth}{|l|l|l|X|}
\hline
\textbf{Week} & \textbf{Module(s)} & \textbf{Lead(s)} & \textbf{Details} \\ \hline
Mar 20 - Mar 30 & M9 & Savinay & \textbf{View-Render:} Finalizing the Desktop Panel; rendering 
transcript overlays and real-time status indicators. \\ \hline
Mar 31 - Apr 9 & M8 & Amanbeer & \textbf{Voice-Synth:} Integration of TTS to convert system 
responses into spoken audio via the M1 interface. \\ \hline
Apr 10 - Apr 19 & All & Full Team & \textbf{V\&V:} Execution of the Confidence Protocol; 
testing latency (SAL.R.1) and safety-interception reliability. \\ \hline
\end{tabularx}

\subsection{Verification Milestones}
To ensure implementation confidence, the following milestones must be met by 
Apr 20 - Apr 25:
\begin{enumerate}
    \item \textbf{Control Loop Integrity:} Successful movement from 
    \texttt{M1 (Audio)} to \texttt{M2 (Automation)} for a "hello world" command
    (Gourob to Verify).
    \item \textbf{Safety Intercept:} Verification that M6 (Savinay) halts any 
    plan involving file deletion or high risk action until M9 receives user 
    confirmation.
    \item \textbf{Performance Gate:} Total system latency from end-of-speech to 
    start-of-action must be less than 8 seconds (Amanbeer/Ajay to verify via logs).
\end{enumerate}


\bibliographystyle{plainnat}
\bibliography{../../../refs/References}

\newpage{}

\end{document}